const{isArray:isArray}=Array,connections=[],isString=e=>"string"==typeof e,has=async(e,t)=>{isString(e)||console.error(`${e} should be a string`);isString(t)||isArray(t)||console.error(`${t} should be a string or an array`);const r=await openDatabase(e,isArray(t)?t:[t]);return isArray(t)?t.every((e=>r.objectStoreNames.contains(e))):r.objectStoreNames.contains(t)},deleteDatabase=async e=>deleteDB(e),openDatabase=(e="default",t)=>new Promise(((r,s)=>{const a=window.indexedDB.open(e,1);a.onupgradeneeded=({target:e})=>{const{result:r}=e;t.forEach((e=>{if(!r.objectStoreNames.contains(e)){r.createObjectStore(e).onerror=e=>s(e.target.error)}}))},a.onsuccess=({target:e})=>{connections.push(a),r(e.result)},a.onerror=({target:e})=>s(e.result)})),setData=async(e,t,r,s,a)=>new Promise(((n,o)=>{try{const o=e.transaction([t],"readwrite").objectStore(t);if(a){const e=isArray(s)?()=>s.map(((e,t)=>o.put(e,t))):()=>Object.entries(s).map((([e,t])=>o.put(t,e)));n(Promise.all(e()))}else n(o.put(s,r))}catch(e){o(e)}})),getData=async(e,t,r,s)=>new Promise(((a,n)=>{e.objectStoreNames.contains(t)||console.error(`Store ${t} was not found in database ${e}`);const o=e.transaction([t]).objectStore(t);if(s){const e={},t=o.openCursor();t.onsuccess=t=>{const s=t.target.result;s?(r.includes(s.key)&&(e[s.key]=s.value),s.continue()):a(e)},t.onerror=e=>n(e)}else{const e=o.get(r);e.onsuccess=()=>a(e.result),e.onerror=e=>n(e)}})),deleteData=async(e,t,r)=>new Promise(((s,a)=>{try{const n=e.transaction([t],"readwrite").objectStore(t).openCursor();n.onsuccess=e=>{const t=e.target.result;t&&((isArray(r)?r:[r]).includes(t.key)&&t.delete(),t.continue())},n.onerror=e=>a(e),s(db64)}catch(e){a(e)}})),clearStore=(e,t)=>new Promise(((r,s)=>{const a=e.transaction([t],"readwrite").objectStore(t).clear();a.onsuccess=()=>r(db64),a.onerror=e=>s(e.target.error)})),deleteDB=e=>{const t=[];return new Promise(((r,s)=>{const a=indexedDB.deleteDatabase(e);a.onsuccess=()=>r(db64),a.onerror=e=>s(e),a.onblocked=()=>{for(const r of connections)r.result.name===e&&(r.result.close(),t.push(e));t.includes(e)?r(db64):deleteDB(e)}}))},db64={create:async(e,t,r="enable-delete")=>{if(isString(e)||console.error(`${e} should be a string`),!isArray(t))return console.error(`${t} should be an array`);return"disable-delete"===r||await has(e,t)||(console.log("delete"),await deleteDB(e)),openDatabase(e,t)},has:has,use:(e,t)=>(isString(e)||console.error(`${e} should be a string`),isString(t)||console.error(`${t} should be a string`),{set:async(r,s)=>openDatabase(e,[t]).then((e=>setData(e,t,r,s))),setEntries:async r=>openDatabase(e,t).then((e=>setData(e,t,null,r,"entries"))),get:async r=>openDatabase(e,t).then((e=>getData(e,t,r))),getEntries:async r=>openDatabase(e,t).then((e=>getData(e,t,r,"entries"))),delete:async r=>openDatabase(e,t).then((e=>deleteData(e,t,r)))}),clear:async(e,t)=>openDatabase(e,t).then((e=>clearStore(e,t))),delete:deleteDatabase};export default db64;
//# sourceMappingURL=db64.min.map